## 🧭 通用 Prompt 模板：结构化笔记生成（Notion 风格）

> **提示语标题：** 「为任意主题生成高质量 Notion 风格笔记」

### 🧾 Prompt 内容（建议保存或固定在 Notion / ChatGPT 收藏夹）

---

你是一个专业的知识整理师，请根据我提供的主题内容，

生成一篇  **结构化、可直接粘贴进 Notion 使用的笔记** 。

请遵循以下写作规范：

### 📘 输出要求：

1. **标题结构清晰** ，包含一级标题（#）和分级小标题（##、###）。
2. **语言风格** ：简洁、有逻辑、读起来像知识卡片或笔记，不像论文。
3. **内容结构统一** （参考下列标准结构模板）。
4. **视觉友好** ：使用表情符号、表格、引用、代码块或项目符号，便于 Notion 展示。
5. **避免多余的引言或总结性废话** ，聚焦核心信息。
6. **篇幅适中** （约 800–1200 字）。

---

### 📐 标准结构模板：

请尽量遵循以下结构（若主题不适合，可略微调整）：

<pre class="overflow-visible!" data-start="653" data-end="944"><div class="contain-inline-size rounded-2xl relative bg-token-sidebar-surface-primary"><div class="sticky top-9"><div class="absolute end-0 bottom-0 flex h-9 items-center pe-2"><div class="bg-token-bg-elevated-secondary text-token-text-secondary flex items-center gap-4 rounded-sm px-2 font-sans text-xs"></div></div></div><div class="overflow-y-auto p-4" dir="ltr"><code class="whitespace-pre!"><span><span># </span><span><span class="language-bash">🧭 [主题名称]笔记 — [一句话副标题]</span></span><span>

#</span><span><span class="language-bash"># 💡 一、概念定义</span></span><span>
简要介绍该主题是什么，解决什么问题，核心关键词解释。

#</span><span><span class="language-bash"># 🧠 二、核心原理 / 核心思想</span></span><span>
解释背后的逻辑、结构或组成要素。

#</span><span><span class="language-bash"># 🧩 三、关键要点 / 操作步骤</span></span><span>
按顺序说明主要步骤或方法，适当用编号（①②③）。

#</span><span><span class="language-bash"># 📊 四、案例 / 示例</span></span><span>
提供 1–2 个具体的实际例子（如工作场景、项目应用）。

#</span><span><span class="language-bash"># 🚀 五、优势与价值</span></span><span>
列出应用该方法的主要好处。

#</span><span><span class="language-bash"># ⚠️ 六、常见误区或注意事项</span></span><span>
总结容易出错或误解的地方。

#</span><span><span class="language-bash"># 🧭 七、小结</span></span><span>
一句话总结核心公式或理念。
</span></span></code></div></div></pre>

---

### 📗 风格参考：

请模仿以下笔记的格式和风格：

`<example>`


# 🧭 语义化版本规范（Semantic Versioning, SemVer）笔记

---

## 💡 一、什么是语义化版本（SemVer）？

**语义化版本（Semantic Versioning, 简称 SemVer）** 是一种统一的软件版本号命名规范，旨在通过版本号直接表达“修改的意义”和“兼容性影响”。

标准格式为：

> 主版本号.次版本号.修订号
>
> 例如：`2.5.3`

---

## 🧩 二、版本号结构

| 序号  | 名称     | 英文            | 含义                                             | 示例             |
| ----- | -------- | --------------- | ------------------------------------------------ | ---------------- |
| 1️⃣ | 主版本号 | **MAJOR** | 当你做了**不兼容**的 API 修改时递增        | v1 → v2         |
| 2️⃣ | 次版本号 | **MINOR** | 当你新增功能，**兼容旧版本**时递增         | v1.1 → v1.2     |
| 3️⃣ | 修订号   | **PATCH** | 当你修复 bug，**不影响功能或兼容性**时递增 | v1.2.0 → v1.2.1 |

📘 **规则：**

* 当主版本号递增时，次版本号与修订号  **归零** 。
* 当次版本号递增时，修订号  **归零** 。

---

## ⚙️ 三、示例对照表

| 版本号    | 含义         | 说明                   |
| --------- | ------------ | ---------------------- |
| `1.0.0` | 初始稳定版本 | API 确认稳定并正式发布 |
| `1.0.1` | 修复 Bug     | 无功能变化，仅修复问题 |
| `1.1.0` | 新增功能     | 保持向后兼容           |
| `2.0.0` | 大版本更新   | 不兼容旧版本接口       |
| `2.1.3` | 小更新与修复 | 在 2.x 系列中继续维护  |

---

## 🔢 四、预发布版本与构建元数据

语义化版本还支持 **预发布版本（Pre-release）和构建元数据（Build Metadata）** 。

### 1️⃣ 预发布版本（Pre-release）

用于尚未正式稳定的版本，如测试、候选或内部发布。

格式示例：

* `1.0.0-alpha`
* `1.0.0-beta.2`
* `1.0.0-rc.1`

🧩 **规则：**

* 以连字符  连接主版本号后。
* 表示版本 **不稳定** ，可能会有重大变更。
* 排序规则：
  `alpha < beta < rc < stable`

### 2️⃣ 构建元数据（Build Metadata）

用于标识构建信息（如编译号、时间戳等）。

格式示例：

* `1.0.0+20250315`
* `1.0.0-beta+exp.sha.5114f85`

📘 **规则：**

* 以加号 `+` 连接， **不影响版本排序** 。
* 常用于 CI/CD 构建、内部追踪。

---

## 🧠 五、版本递增规则（核心逻辑）

| 修改类型           | 是否兼容旧版本 | 递增字段 | 示例           |
| ------------------ | -------------- | -------- | -------------- |
| 修复 bug           | ✅ 是          | PATCH    | 1.0.0 → 1.0.1 |
| 新增功能（兼容）   | ✅ 是          | MINOR    | 1.0.1 → 1.1.0 |
| 改动接口（不兼容） | ❌ 否          | MAJOR    | 1.2.5 → 2.0.0 |

---

## 🧩 六、SemVer 的价值

| 优势                     | 说明                                                |
| ------------------------ | --------------------------------------------------- |
| 🧭**可预测性**     | 通过版本号即可判断改动规模与风险                    |
| 🔄**依赖管理方便** | 包管理器可自动判断兼容性                            |
| 💬**团队沟通清晰** | 减少“版本含义不明”的混乱                          |
| 🧱**标准统一**     | 被广泛采用（Node.js、Python、Rust、Go、Java等生态） |

---

## ⚠️ 七、常见误区

| 误区                    | 说明                       | 正确做法                   |
| ----------------------- | -------------------------- | -------------------------- |
| ⚠️ 忘记重置次级版本号 | 发布 v1.2 → v2.0 时忘清零 | 应为 `2.0.0`             |
| ⚠️ 滥用补丁号         | 新功能也加 PATCH           | 新功能应加 MINOR           |
| ⚠️ 不标预发布版本     | Beta 测试直接上正式号      | 用 `-beta`或 `-rc`标明 |
| ⚠️ 无变更也更新版本   | 版本号滥升，失去意义       | 保持语义一致性             |

---

## 🔍 八、语义化版本的依赖规则（常用于包管理）

| 依赖写法           | 含义                                | 举例说明           |
| ------------------ | ----------------------------------- | ------------------ |
| `^1.2.3`         | 兼容 1.x 的所有版本（不升级到 2.0） | 允许 1.3.0, 1.4.5  |
| `~1.2.3`         | 锁定次版本，允许补丁更新            | 允许 1.2.4, 1.2.9  |
| `1.2.x`          | 仅允许修订号变化                    | 等价于 `~1.2.0`  |
| `>=1.2.0 <2.0.0` | 显式声明兼容范围                    | 常用于严格控制依赖 |

---

## 🧭 九、小结

> 语义化版本（SemVer） = MAJOR.MINOR.PATCH + [Pre-release] + [Build Metadata]

💬 **核心理念：**

* **主版本号变 = 不兼容**
* **次版本号变 = 新功能**
* **修订号变 = 修 Bug**

🎯 **记住：版本号不仅是数字，更是沟通语言。**

`</example>`

这些笔记的特点包括：

* 有层级感的标题结构
* 每段开头带 emoji 图标
* 表格展示对比信息
* 每部分之间留有分隔线（---）
* 总结简洁有力

---

### 🧩 示例使用方法：

> Prompt 示例：
>
> “请根据下面主题生成一篇 Notion 风格笔记，结构参照我固定的模板：
>
> **主题：OKR 方法论（目标与关键结果）** ”
>
